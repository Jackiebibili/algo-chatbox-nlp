Question,Answers
What is a sorting algorithm?,"A sorting algorithm describes the method by which we determine the sorted order, regardless of whether we are sorting individual numbers or large records containing many bytes of satellite data."
Why sorting?,"Many computer scientists consider sorting to be the most fundamental problem in the study of algorithms. There are several reasons: Sometimes an application inherently needs to sort information. For example, in order to prepare customer statements, banks need to sort checks by check number. Algorithms often use sorting as a key subroutine. For example, a program that renders graphical objects which are layered on top of each other might have to sort the objects according to an “above” relation so that it can draw these objects from bottom to top. We shall see numerous algorithms in this text that use sorting as a subroutine. We can draw from among a wide variety of sorting algorithms, and they employ a rich set of techniques. In fact, many important techniques used throughout algorithm design appear in the body of sorting algorithms that have been developed over the years. In this way, sorting is also a problem of historical interest. We can prove a nontrivial lower bound for sorting (as we shall do in Chapter 8). Our best upper bounds match the lower bound asymptotically, and so we know that our sorting algorithms are asymptotically optimal. Moreover, we can use the lower bound for sorting to prove lower bounds for certain other problems. Many engineering issues come to the fore when implementing sorting algorithms. The fastest sorting program for a particular situation may depend on many factors, such as prior knowledge about the keys and satellite data, the memory hierarchy (caches and virtual memory) of the host computer, and the software environment. Many of these issues are best dealt with at the algorithmic level, rather than by “tweaking” the code."
How long does insertion sort take?,Insertion sort takes O(N^2) time in the worst case.
How long does merge sort take?,"Merge sort has a better asymptotic running time,O(n lg n) but the MERGE procedure it uses does not operate in place."
How long does heapsort take?,"Heapsort sorts n numbers in place in O(n lg n) time. It uses an important data structure, called a heap, with which we can also implement a priority queue."
How long does Quicksort take?,"Quicksort sorts n numbers in place, but its worst-case running time is O(n^2). Its expected running time is O(n lg n), however, and it generally outperforms heapsort in practice. Like insertion sort, quicksort has tight code, and so the hidden constant factor in its running time is small. It is a popular algorithm for sorting large input arrays."
"What are the similarities between Insertion sort, merge sort, heapsort, and quick sort?","Insertion sort, merge sort, heapsort, and quicksort are all comparison sorts: they determine the sorted order of an input array by comparing elements."
How long does counting sort take?,"The counting sort algorithm, for example, assumes that the input numbers are in the set {0, 1,..., k}. By using array indexing as a tool for determining relative order, counting sort can sort n numbers in O(k + n) time. Thus, when k = O(n) counting sort runs in time that is linear in the size of the input array."
How long does radix sort take?,"Radix sort can be used to extend the range of counting sort. If there are n integers to sort, each integer has d digits, and each digit can take on up to k possible values, then radix sort can sort the numbers in O(d(n + k)) time. When d is a constant and k is O(n) radix sort runs in linear time."
How long does bucket sort take?,"Bucket sort requires knowledge of the probabilistic distribution of numbers in the input array. It can sort n real numbers uniformly distributed in the half-open interval [0, 1)in average-case O(n) time."
What is Heapsort?,"Like merge sort, but unlike insertion sort, heapsort’s running time is O(n lg n). Like insertion sort, but unlike merge sort, heapsort sorts in place: only a constant number of array elements are stored outside the input array at any time. Thus, heapsort combines the better attributes of the two sorting algorithms we have already discussed. Heapsort also introduces another algorithm design technique: using a data structure, in this case one we call a “heap,” to manage information. Not only is the heap data structure useful for heapsort, but it also makes an efficient priority queue. The heap data structure will reappear in algorithms in later chapters. The term “heap” was originally coined in the context of heapsort, but it has since come to refer to “garbage-collected storage,” such as the programming languages Java and Lisp provide. Our heap data structure is not garbage-collected storage, and whenever we refer to heaps in this book, we shall mean a data structure rather than an aspect of garbage collection."
What is a heap?,"The (binary) heap data structure is an array object that we can view as a nearly complete binary tree. Each node of the tree corresponds to an element of the array. The tree is completely filled on all levels except possibly the lowest, which is filled from the left up to a point."
What are different kinds of binary heaps?,"Max-heaps and min-heaps. In both kinds, the values in the nodes satisfy a heap property, the specifics of which depend on the kind of heap."
What is a max heap?,"In a max-heap, the max-heap property is that for every node i other than the root, A[PARENT(i)] >= A[i]; that is, the value of a node is at most the value of its parent. Thus, the largest element in a max-heap is stored at the root, and the subtree rooted at a node contains values no larger than that contained at the node itself."
What is a min heap?,"A min-heap is organized in the opposite way; the min-heap property is that for every node i other than the root, A[PARENT(i)] <= A[i]: The smallest element in a min-heap is at the root."
What is a priority queue?,"A priority queue is a data structure for maintaining a set S of elements, each with an associated value called a key."
What is a max-priority queue?,"A max-priority queue supports the following operations: INSERT(S, x), inserts the element x into the set S, which is equivalent to the operation S = S U {x}. MAXIMUM(S) returns the element of S with the largest key. EXTRACT-MAX(S) removes and returns the element of S with the largest key. INCREASE-KEY (S, x, k) increases the value of element x’s key to the new value k, which is assumed to be at least as large as x’s current key value. Among their other applications, we can use max-priority queues to schedule jobs on a shared computer. The max-priority queue keeps track of the jobs to be performed and their relative priorities. When a job is finished or interrupted, the scheduler selects the highest-priority job from among those pending by calling EXTRACT-MAX. The scheduler can add a new job to the queue at any time by calling INSERT."
What is a min-priority queue?,"A min-priority queue supports the operations INSERT, MINIMUM, EXTRACT-MIN, and DECREASE-KEY. A min-priority queue can be used in an event-driven simulator. The items in the queue are events to be simulated, each with an associated time of occurrence that serves as its key. The events must be simulated in order of their time of occurrence, because the simulation of an event can cause other events to be simulated in the future. The simulation program calls EXTRACT-MIN at each step to choose the next event to simulate. As new events are produced, the simulator inserts them into the min-priority queue by calling INSERT."
What is a comparison sort?,The sorted order they determine is based only on comparisons between the input elements.
What is a decision tree?,"A decision tree is a full binary tree that represents the comparisons between elements that are performed by a particular sorting algorithm operating on an input of a given size. Control, data movement, and all other aspects of the algorithm are ignored."
What is a counting sort?,"Counting sort assumes that each of the n input elements is an integer in the range 0 to k, for some integer k. When k = O(n), the sort runs in O(n) time. Counting sort determines, for each input element x, the number of elements less than x."
What is a radix sort?,"Radix sorts on the least significant digit first. The algorithm then combines the cards into a single deck, with the cards in the 0 bin preceding the cards in the 1 bin preceding the cards in the 2 bin, and so on. Then it sorts the entire deck again on the second-least significant digit and recombines the deck in a like manner. The process continues until the cards have been sorted on all d digits. Remarkably, at that point the cards are fully sorted on the d-digit number. Thus, only d passes through the deck are required to sort."
What is bucket sort?,"Bucket sort assumes that the input is drawn from a uniform distribution and has an average-case running time of O(n). Like counting sort, bucket sort is fast because it assumes something about the input. Whereas counting sort assumes that the input consists of integers in a small range, bucket sort assumes that the input is generated by a random process that distributes elements uniformly and independently over the interval [0,1)."
How does the bucket sort divide into buckets?,"Bucket sort divides the interval [0,1) into n equal-sized subintervals, or buckets, and then distributes the n input numbers into the buckets. Since the inputs are uniformly and independently distributed over [0,1), we do not expect many numbers to fall into each bucket. To produce the output, we simply sort the numbers in each bucket and then go through the buckets in order, listing the elements in each."
How do we represent a graph?,"We can choose between two standard ways to represent a graph G = (V, E): as a collection of adjacency lists or as an adjacency matrix. Either way applies to both directed and undirected graphs."
How do we represent a sparse graph?,Those for which |E| is much less than |V|^ 2—it is usually the method of choice.
How do we represent a dense graph?,When the graph is dense—|E| is close to |V|^2
What is breadth-first search?,"Breadth-first search is one of the simplest algorithms for searching a graph and the archetype for many important graph algorithms. Prim’s minimum-spanning-tree algorithm and Dijkstra’s single-source shortest-paths algorithm use ideas similar to those in breadth-first search. Given a graph G = (V, E) and a distinguished source vertex s, breadth-first search systematically explores the edges of G to “discover” every vertex that is reachable from s. It computes the distance (smallest number of edges) from s to each reachable vertex. It also produces a “breadth-first tree” with root s that contains all reachable vertices. For any vertex reachable from s, the simple path in the breadth-first tree from s to corresponds to a “shortest path” from s to in G, that is, a path containing the smallest number of edges. The algorithm works on both directed and undirected graphs. Breadth-first search is so named because it expands the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier. That is, the algorithm discovers all vertices at distance k from s before discovering any vertices at distance k + 1. To keep track of progress, breadth-first search colors each vertex white, gray, or black. All vertices start out white and may later become gray and then black. A vertex is discovered the first time it is encountered during the search, at which time it becomes nonwhite. Gray and black vertices, therefore, have been discovered, but breadth-first search distinguishes between them to ensure that the search proceeds in a breadth-first manner.1 If (u, v) e E and vertex u is black, then vertex is either gray or black; that is, all vertices adjacent to black vertices have been discovered. Gray vertices may have some adjacent white vertices; they represent the frontier between discovered and undiscovered vertices. Breadth-first search constructs a breadth-first tree, initially containing only its root, which is the source vertex s. Whenever the search discovers a white vertex in the course of scanning the adjacency list of an already discovered vertex u, the vertex and the edge (u,v) are added to the tree. We say that u is the predecessor or parent of v in the breadth-first tree. Since a vertex is discovered at most once, it has at most one parent. Ancestor and descendant relationships in the breadth-first tree are defined relative to the root s as usual: if u is on the simple path in the tree from the root s to vertex , then u is an ancestor of and is a descendant of u."
What is depth-first search?,"The strategy followed by depth-first search is, as its name implies, to search “deeper” in the graph whenever possible. Depth-first search explores edges out of the most recently discovered vertex that still has unexplored edges leaving it. Once all of ’s edges have been explored, the search “backtracks” to explore edges leaving the vertex from which was discovered. This process continues until we have discovered all the vertices that are reachable from the original source vertex. If any undiscovered vertices remain, then depth-first search selects one of them as a new source, and it repeats the search from that source. The algorithm repeats this entire process until it has discovered every vertex."
What are some properties of depth-first search?,"Depth-first search yields valuable information about the structure of a graph. Perhaps the most basic property of depth-first search is that the predecessor subgraph G does indeed form a forest of trees, since the structure of the depth-first trees exactly mirrors the structure of recursive calls of DFS-VISIT. That is, u = v.𝝅: if and only if DFS-VISIT (G, v) was called during a search of u’s adjacency list. Additionally, vertex is a descendant of vertex u in the depth-first forest if and only if v is discovered during the time in which u is gray. Another important property of depth-first search is that discovery and finishing times have parenthesis structure. If we represent the discovery of vertex u with a left parenthesis “(u” and represent its finishing by a right parenthesis “u)”, then the history of discoveries and finishings makes a well-formed expression in the sense that the parentheses are properly nested."
What is a spanning tree?,"A Spanning Tree is an acyclic graph that connects all of the vertices, it must form a tree, which we call a spanning tree since it “spans” the graph G ."
Which algorithms solve the minimum-spanning tree problem?,Kruskal’s algorithm and Prim’s algorithm.
What is the run time of Prim’s and Kruskal’s algorithm when solving the minimum spanning tree problem?,"We can easily make each of them run in time O(E lg V ) using ordinary binary heaps. By using Fibonacci heaps, Prim’s algorithm runs in time O(E + V lg V ) , which improves over the binary-heap implementation if |V| is much smaller than |E|."
What is the generic method on Kruskal’s algorithm?,"In Kruskal’s algorithm, the set A is a forest whose vertices are all those of the given graph. The safe edge added to A is always a least-weight edge in the graph that connects two distinct components."
What is the generic method on Prim’s algorithm?,"In Prim’s algorithm, the set A forms a single tree. The safe edge added to A is always a least-weight edge connecting the tree to a vertex not in the tree."
What is Kruskal’s algorithm?,"Kruskal’s algorithm finds a safe edge to add to the growing forest by finding, of all the edges that connect any two trees in the forest, an edge (u, v) of least weight. Kruskal’s algorithm qualifies as a greedy algorithm because at each step it adds to the forest an edge of least possible weight."
What is Prim’s algorithm?,Prim’s algorithm is a special case of the generic minimum-spanning-tree method from Section 23.1. Prim’s algorithm operates much like Dijkstra’s algorithm for finding shortest paths in a graph. Prim’s algorithm has the property that the edges in the set A always form a single tree.
What is the Bellman-Ford Algorithm?,"The Bellman-Ford algorithm solves the single-source shortest-paths problem in the general case in which edge weights may be negative. The Bellman-Ford algorithm returns a boolean value indicating whether or not there is a negative-weight cycle that is reachable from the source. If there is such a cycle, the algorithm indicates that no solution exists. If there is no such cycle, the algorithm produces the shortest paths and their weights."
What is the run time for Bellman-Ford Algorithm?,"The Bellman-Ford algorithm runs in O(VE) time, since the initialization takes O(V) time, each of the |V| -1 passes over the edges takes O(E) time, and the for loop takes O(E) time."
What is Djikstra’s algorithm?,"Dijkstra’s algorithm solves the single-source shortest-paths problem on a weighted, directed graph G = (V, E) for the case in which all edge weights are nonnegative. Dijkstra’s algorithm maintains a set S of vertices whose ﬁnal shortest-path weights from the source s have already been determined. The algorithm repeatedly selects the vertex u e V - S with the minimum shortest-path estimate, adds u to S , and relaxes all edges leaving u."
What algorithm do we use when all edge weights are nonnegative?,"If all edge weights are nonnegative, we can use Dijkstra’s algorithm."
What algorithm do we use when the graph has negative weight edges?,If the graph has negative-weight edges we must run the slower Bellman-Ford algorithm once from each vertex.
What is the run time of the Floyd-Warshall algorithm?,O(V^3) time.
What is Djikstra’s algorithm runtime?,O(V lg V).
What is the runtime for Johnson’s algorithm?,Johnson’s algorithm finds shortest paths between all pairs in O(V^2 lg V + VE) time.
What is Johnson's algorithm?,The algorithm either returns a matrix of shortest-path weights for all pairs of vertices or reports that the input graph contains a negative-weight cycle. Johnson’s algorithm uses as subroutines both Dijkstra’s algorithm and the Bellman-Ford algorithm. Johnson’s algorithm uses the technique of reweighting.
What is the Ford-Fulkerson algorithm?,"The Ford-Fulkerson method depends on three important ideas that transcend the method and are relevant to many ﬂow algorithms and problems: residual networks, augmenting paths, and cuts."
What is the runtime for the Ford-Fulkerson algorithm?,O(E |f*|)
What is the runtime for the Edmonds-Karp algorithm?,O(V^2) time.
What is the Edmonds-Karp algorithm?,"We choose the augmenting path as a shortest path from s to t in the residual network, where each edge has unit distance (weight)."